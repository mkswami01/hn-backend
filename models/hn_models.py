from pydoc import describe
from pydantic import BaseModel, EmailStr, Field, field_validator, model_validator
from typing import List, Optional, Any
from datetime import datetime


class HNStoryResponse(BaseModel):
    """Pydantic model for validating HN Story API responses"""

    # Required fields - HN API always provides these
    id: int = Field(..., description="HN item ID")
    type: str = Field(..., description="Item type (should be 'story')")
    time: int = Field(..., description="Unix timestamp")

    # Optional fields - sometimes missing or null
    title: Optional[str] = Field(None, description="Story title")
    by: Optional[str] = Field(None, description="Author username")
    score: Optional[int] = Field(0, description="Story score")
    descendants: Optional[int] = Field(0, description="Total comment count")
    kids: Optional[List[int]] = Field(default_factory=list, description="Array of comment IDs")
    url: Optional[str] = Field(None, description="Story URL")

    @field_validator('kids', mode='before')
    def validate_kids(cls, v):
        """Handle null kids field from API"""
        if v is None:
            return []
        return v

    @field_validator('type')
    def validate_type(cls, v):
        """Ensure this is actually a story"""
        if v != 'story':
            raise ValueError(f"Expected type 'story', got '{v}'")
        return v

    def to_datetime(self) -> datetime:
        """Convert HN timestamp to datetime"""
        return datetime.fromtimestamp(self.time)


class HNCommentResponse(BaseModel):
    """Pydantic model for validating HN Comment API responses"""

    # Required fields - HN API always provides these
    id: int = Field(..., description="HN item ID")
    type: str = Field(..., description="Item type (should be 'comment')")
    time: int = Field(..., description="Unix timestamp")

    # Optional fields - can be missing or null for deleted comments
    text: Optional[str] = Field(None, description="Comment text (HTML)")
    by: Optional[str] = Field(None, description="Author username")
    parent: Optional[int] = Field(None, description="Parent item ID")
    kids: Optional[List[int]] = Field(default_factory=list, description="Child comment IDs")
    deleted: Optional[bool] = Field(False, description="Whether comment is deleted")
    dead: Optional[bool] = Field(False, description="Whether comment is dead")

    @field_validator('kids', mode='before')
    def validate_kids(cls, v):
        """Handle null kids field from API"""
        if v is None:
            return []
        return v

    @field_validator('type')
    def validate_type(cls, v):
        """Ensure this is actually a comment"""
        if v != 'comment':
            raise ValueError(f"Expected type 'comment', got '{v}'")
        return v

    def to_datetime(self) -> datetime:
        """Convert HN timestamp to datetime"""
        return datetime.fromtimestamp(self.time)


class DatabaseStoryData(BaseModel):
    """Clean data model for database insertion"""
    # Note: 'id' is auto-generated by database, not included here
    hn_id: int = Field(..., description="HN unique id")
    title: Optional[str] = Field(None, description="Story title")
    month: str = Field(..., description="Month in YYYY-MM format")
    kids_count: int = Field(0, description="Number of direct comments")
    descendants_count: int = Field(0, description="Number of total comments")
    score: int = Field(0, description="Number of votes it got")
    created_time: Optional[datetime] = Field(None, description="When story was created")

    @classmethod
    def from_hn_story(cls, hn_story: 'HNStoryResponse') -> 'DatabaseStoryData':
        """Convert HN API response to database format"""
        created_dt = hn_story.to_datetime()
        return cls(
            hn_id=hn_story.id,
            title=hn_story.title,
            month=created_dt.strftime('%Y-%m'),  # Extract month in YYYY-MM format
            kids_count=len(hn_story.kids or []),
            descendants_count=hn_story.descendants or 0,
            score=hn_story.score or 0,
            created_time=created_dt
        )
    

class DatabaseCommentData(BaseModel):
    """Clean data model for database insertion"""
    # Note: 'id' is auto-generated by database, not included here
    hn_id: int = Field(..., description="HN unique id")
    story_id: int = Field(..., description="Database ID of parent story")
    story_text: Optional[str] = Field(None, description="Comment text")
    structured_data: Optional[dict] = Field(None, description="Extracted job data")
    created_time: Optional[datetime] = Field(None, description="When comment was created")

    @classmethod
    def from_hn_comment(cls, hn_comment: 'HNCommentResponse', story_db_id: int) -> 'DatabaseCommentData':
        """Convert HN API response to database format"""
        return cls(
            hn_id=hn_comment.id,
            story_id=story_db_id,
            story_text=hn_comment.text,
            structured_data=None,  # Will be populated later by processing service
            created_time=hn_comment.to_datetime()
        )

    def model_dump(self) -> dict:
        """Convert to dictionary with datetime serialization for database"""
        data = super().model_dump()
        if data.get('created_time'):
            data['created_time'] = data['created_time'].isoformat()
        return data

# {
#     "company": "SerpApi",
#     "positions": ["Junior Fullstack Engineer", "Senior Fullstack Engineer", "Customer Success Engineer"],
#     "location": "Austin, TX (Remote)",
#     "salary": "$150K - 180K",
#     "stack": ["Ruby", "Rails", "MongoDB", "React.JS"],
#     "remote_friendly": true,
#     "application_url": "https://serpapi.com/careers"
#   }

class OpenAIProcessData(BaseModel):
    """Pydantic model for structured job posting data extracted by OpenAI - Hybrid Approach"""

    # REQUIRED FIELDS - Job posting must have these to be useful
    company: str = Field(..., description="Company name - REQUIRED")
    positions: List[str] = Field(..., min_items=1, description="Job positions (at least one required)")
    description: str =Field(..., description="What does the company do")

    # HIGH-VALUE OPTIONAL FIELDS - Nice to have for user experience
    location: Optional[str] = Field(None, description="Job location (city, state, or 'Remote')")
    salary: Optional[str] = Field(None, description="Salary range or compensation details")
    stack: List[str] = Field(default_factory=list, description="Technology stack requirements")

    # CONTACT FIELDS - At least one should be present for actionable posting
    email: Optional[str] = Field(None, description="Contact email (convert 'at' and 'dot' format)")
    application_url: List[str] = Field(default_factory=list, description="Application URLs or career pages")

    # ADDITIONAL CONTEXT
    remote_friendly: Optional[bool] = Field(None, description="Whether remote work is explicitly supported")
    employment_type: List[str] = Field(default_factory=list, description="Full-time, Part-time, Contract, Internship")

    @model_validator(mode='after')
    def validate_contact_info(self):
        """Ensure job posting has at least one way to apply"""
        if not self.email and not self.application_url:
            raise ValueError("Job posting must have either email or application_url for contact")
        return self

    @field_validator('email', mode='before')
    def clean_email_format(cls, v):
        """Handle HN's common email obfuscation patterns"""
        if not v:
            return v

        # Convert common obfuscation patterns
        v = str(v).lower()
        v = v.replace(' at ', '@').replace('[at]', '@').replace('(at)', '@')
        v = v.replace(' dot ', '.').replace('[dot]', '.').replace('(dot)', '.')

        return v if '@' in v and '.' in v else None

    @field_validator('application_url', mode='before')
    def validate_application_url(cls, v):
        """Handle both strings and lists from AI responses"""
        if v is None:
            return []
        if isinstance(v, str):
            return [v]  # Convert single string to list
        if isinstance(v, list):
            return v
        return []

    @field_validator('stack', mode='before')
    def validate_stack(cls, v):
        """Handle both strings and lists from AI responses"""
        if v is None:
            return []
        if isinstance(v, str):
            return [v]  # Convert single string to list
        if isinstance(v, list):
            return v
        return []

    @field_validator('positions', mode='before')
    def validate_positions(cls, v):
        """Handle both strings and lists from AI responses"""
        if v is None:
            raise ValueError("At least one position is required - not a valid job posting")
        if isinstance(v, str):
            if v.strip() == "":
                raise ValueError("At least one position is required - not a valid job posting")
            return [v]  # Convert single string to list
        if isinstance(v, list):
            if len(v) == 0:
                raise ValueError("At least one position is required - not a valid job posting")
            return v
        raise ValueError("At least one position is required - not a valid job posting")
    
    @field_validator('description', mode='before')
    def validate_description(cls, v):
        """Ensure description is provided - required for useful job posting"""
        if v is None or v == "" or str(v).strip() == "":
            raise ValueError("Company description is required - not a valid job posting")
        return str(v).strip()

    @field_validator('employment_type', mode='before')
    def validate_employment_type(cls, v):
        """Handle both strings and lists from AI responses"""
        if v is None:
            return []
        if isinstance(v, str):
            return [v]  # Convert single string to list
        if isinstance(v, list):
            return v
        return []

    @field_validator('remote_friendly', mode='before')
    def validate_remote_friendly(cls, v):
        """Convert string descriptions to boolean values"""
        if v is None:
            return None
        if isinstance(v, bool):
            return v
        if isinstance(v, str):
            v_lower = v.lower()
            # Check for remote-friendly indicators
            if any(word in v_lower for word in ['remote', 'hybrid', 'distributed', 'work from home']):
                return True
            # Check for onsite-only indicators
            if any(word in v_lower for word in ['onsite', 'office only', 'no remote', 'in-person']):
                return False
            # If unclear, default to None
            return None
        return None

    @field_validator('company', mode='before')
    def validate_company(cls, v):
        """Ensure company name is a clean string"""
        if v is None or v == "":
            raise ValueError("Company name is required - not a valid job posting")
        return str(v).strip()

    @field_validator('location', mode='before')
    def validate_location(cls, v):
        """Handle location field variations"""
        if v is None:
            return None
        if isinstance(v, list) and len(v) > 0:
            return str(v[0]).strip()  # Take first location if list
        return str(v).strip()

    @field_validator('salary', mode='before')
    def validate_salary(cls, v):
        """Handle salary field variations"""
        if v is None:
            return None
        if isinstance(v, list) and len(v) > 0:
            return str(v[0]).strip()  # Take first salary if list
        return str(v).strip()

    class Config:
        """Model configuration"""
        extra = "ignore"  # Ignore unexpected fields from OpenAI
        str_strip_whitespace = True  # Automatically trim whitespace 
